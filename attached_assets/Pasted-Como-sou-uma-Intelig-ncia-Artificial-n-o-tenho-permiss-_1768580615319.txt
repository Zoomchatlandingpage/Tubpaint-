Como sou uma Intelig√™ncia Artificial, n√£o tenho permiss√£o para acessar sua conta do GitHub e fazer *commits* ou *pushes* diretamente no seu reposit√≥rio.

No entanto, posso atuar como seu **Arquiteto de Software S√™nior**. Vou escrever o c√≥digo completo e refinado aqui, organizado exatamente como deve ficar na sua estrutura de pastas. Voc√™ (ou seu desenvolvedor) s√≥ precisar√° copiar e colar nos arquivos indicados.

Abaixo est√° o **Pacote de Implementa√ß√£o "Sales Machine"**, transformando seu projeto de um simples gerador de or√ßamentos em uma ferramenta de convers√£o de vendas audit√°vel.

---

### üìÇ Arquivo 1: O C√©rebro de Dados

**Caminho:** `shared/schema.ts`
**Assinatura:** `// Architect: Gemini (Database & Sales Engine) - Updated: 2026-01-16`

**Mudan√ßa Principal:** Adaptamos o schema anterior para o **Drizzle ORM** (que voc√™ j√° usa). Criamos tabelas separadas para `Leads` (pessoas), `AIAnalysis` (o que a IA viu) e `PricingConfig` (regras de pre√ßo), separando a intelig√™ncia da matem√°tica.

```typescript
// Architect: Gemini (Database & Sales Engine) - Updated: 2026-01-16
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, integer, timestamp, boolean, jsonb, real } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// 1. LEAD: O ativo mais valioso. Quem √© o cliente?
export const leads = pgTable("leads", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: text("email").unique(),
  name: text("name"),
  phone: text("phone"),
  source: text("source").default("landing_page"), // ex: manual_entry, landing_page
  status: text("status").default("NEW"), // NEW, CONTACTED, QUALIFIED, CLOSED
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// 2. PRICING CONFIG: Regras de neg√≥cio versionadas (Matem√°tica Blindada)
export const pricingConfigs = pgTable("pricing_configs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  version: integer("version").notNull().unique(), // Vers√£o 1, 2, 3...
  basePrice: integer("base_price").notNull(), // Em centavos (ex: 45000 = $450.00)
  pricePerSqft: integer("price_per_sqft").default(0),
  peelingMultiplier: real("peeling_multiplier").default(1.5),
  complexityMultipliers: jsonb("complexity_multipliers").notNull(), // { "cast_iron": 1.2, "fiberglass": 1.0 }
  isActive: boolean("active").default(true),
  createdAt: timestamp("created_at").default(sql`now()`),
});

// 3. AI ANALYSIS: O diagn√≥stico t√©cnico (A "Vis√£o")
export const aiAnalyses = pgTable("ai_analyses", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  provider: text("provider").default("gemini"), // openai, gemini
  rawResponse: jsonb("raw_response"), // O JSON puro que a IA retornou (para auditoria)
  
  // Dados extra√≠dos para consulta r√°pida
  detectedMaterial: text("detected_material"), // cast_iron, fiberglass
  damageLevel: text("damage_level"), // low, moderate, high
  hasPeeling: boolean("has_peeling").default(false),
  confidenceScore: real("confidence_score"),
  
  imageUrl: text("image_url"), // Caminho da imagem analisada
  createdAt: timestamp("created_at").default(sql`now()`),
});

// 4. QUOTES: O Or√ßamento final ligado a tudo
export const quotes = pgTable("quotes", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  
  // Relacionamentos
  leadId: varchar("lead_id").references(() => leads.id),
  aiAnalysisId: varchar("ai_analysis_id").references(() => aiAnalyses.id),
  pricingConfigId: varchar("pricing_config_id").references(() => pricingConfigs.id),
  serviceTypeId: varchar("service_type_id"), // Mantido para compatibilidade com seu c√≥digo antigo
  
  // Valores Financeiros
  totalPrice: integer("total_price"), // Pre√ßo final calculado (centavos)
  estimatedRange: text("estimated_range"), // Ex: "$450 - $600" (Psicol√≥gico)
  complexityScore: real("complexity_score"), // O multiplicador final usado
  
  status: text("status").default("PENDING"), // PENDING, SENT, ACCEPTED
  createdAt: timestamp("created_at").default(sql`now()`),
});

// Tabelas Legadas/Auxiliares (Mantidas para n√£o quebrar seu admin atual)
export const serviceTypes = pgTable("service_types", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  basePrice: integer("base_price"),
  active: boolean("active").default(true),
});

export const adminConfig = pgTable("admin_config", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  webhookUrl: text("webhook_url"),
  llmProvider: text("llm_provider").default("gemini"),
  llmApiKey: text("llm_api_key"),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Schemas Zod para Insert
export const insertLeadSchema = createInsertSchema(leads).omit({ id: true, createdAt: true, updatedAt: true });
export const insertQuoteSchema = createInsertSchema(quotes).omit({ id: true, createdAt: true });

// Tipos Exportados
export type Lead = typeof leads.$inferSelect;
export type Quote = typeof quotes.$inferSelect;
export type AIAnalysis = typeof aiAnalyses.$inferSelect;

```

---

### üìÇ Arquivo 2: Os Olhos da IA

**Caminho:** `server/services/vision-service.ts`
**Assinatura:** `// Developer: Vision Agent - Updated: 2026-01-16`

**Mudan√ßa Principal:** Removemos a l√≥gica de pre√ßo da IA. Agora ela foca 100% em ser um "T√©cnico Virtual" que identifica materiais e danos.

```typescript
// Developer: Vision Agent - Updated: 2026-01-16
import { GoogleGenerativeAI } from "@google/generative-ai";
import { z } from "zod";

// Schema estrito do que a IA deve retornar
const VisionResponseSchema = z.object({
  material: z.enum(["cast_iron", "steel", "fiberglass", "acrylic", "unknown"]),
  surround_type: z.enum(["tile", "plastic_panel", "painted_wall", "none", "unknown"]),
  damage_level: z.enum(["low", "moderate", "high"]),
  has_peeling: z.boolean().describe("True if there is existing paint peeling off"),
  has_rust: z.boolean(),
  confidence_score: z.number().min(0).max(1),
  technical_notes: z.string().describe("Short technical observation about the condition"),
});

export type VisionAnalysisResult = z.infer<typeof VisionResponseSchema>;

export class VisionService {
  private genAI: GoogleGenerativeAI;

  constructor(apiKey: string) {
    if (!apiKey) throw new Error("GEMINI_API_KEY is required for VisionService");
    this.genAI = new GoogleGenerativeAI(apiKey);
  }

  async analyzeBathroomImage(imageBase64: string): Promise<VisionAnalysisResult> {
    const model = this.genAI.getGenerativeModel({ 
      model: "gemini-1.5-flash",
      generationConfig: { responseMimeType: "application/json" } // For√ßa JSON
    });

    const prompt = `
      You are an expert Bathtub Refinishing Technician.
      Analyze this image strictly for technical attributes.
      
      CRITICAL RULES:
      1. IGNORE prices or costs. Focus only on physical condition.
      2. 'has_peeling' is CRITICAL. Look closely for flaking paint from previous bad jobs.
      3. Identify if the tub is Cast Iron (looks heavy, rounded deep edges) or Fiberglass (hollow, molded).
      
      Return JSON matching this schema:
      {
        "material": "cast_iron" | "fiberglass" | "acrylic" | "steel" | "unknown",
        "surround_type": "tile" | "plastic_panel" | "painted_wall" | "none",
        "damage_level": "low" | "moderate" | "high",
        "has_peeling": boolean,
        "has_rust": boolean,
        "confidence_score": 0.0 to 1.0,
        "technical_notes": "string"
      }
    `;

    try {
      const result = await model.generateContent([
        prompt,
        { inlineData: { data: imageBase64, mimeType: "image/jpeg" } }
      ]);

      const text = result.response.text();
      // Parse e Valida√ß√£o com Zod
      const parsed = JSON.parse(text);
      return VisionResponseSchema.parse(parsed);

    } catch (error) {
      console.error("Vision Analysis Failed:", error);
      // Fallback seguro em caso de falha da IA (n√£o quebra o app)
      return {
        material: "unknown",
        surround_type: "unknown",
        damage_level: "low",
        has_peeling: false,
        has_rust: false,
        confidence_score: 0,
        technical_notes: "AI Analysis failed, manual review required."
      };
    }
  }
}

```

---

### üìÇ Arquivo 3: A Calculadora de Vendas

**Caminho:** `server/services/pricing-service.ts`
**Assinatura:** `// Developer: Sales Logic Module - Updated: 2026-01-16`

**Mudan√ßa Principal:** Nova l√≥gica determin√≠stica. Recebe o que a IA viu e aplica as regras de neg√≥cio (multiplicadores) definidos por voc√™.

```typescript
// Developer: Sales Logic Module - Updated: 2026-01-16
import { VisionAnalysisResult } from "./vision-service";

interface PricingRules {
  basePrice: number; // centavos
  peelingMultiplier: number;
  materialMultipliers: Record<string, number>;
}

// Configura√ß√£o Padr√£o (Simulando o DB por enquanto)
const CURRENT_PRICING: PricingRules = {
  basePrice: 45000, // $450.00
  peelingMultiplier: 1.5, // +50% se tiver descascando
  materialMultipliers: {
    "cast_iron": 1.0,
    "steel": 1.0,
    "fiberglass": 1.1, // Fibra as vezes precisa de mais reparo estrutural
    "acrylic": 1.1,
    "unknown": 1.2 // Margem de seguran√ßa
  }
};

export class PricingService {
  
  calculateQuote(analysis: VisionAnalysisResult) {
    let multiplier = 1.0;
    const logs: string[] = [];

    // 1. Fator Material
    const matFactor = CURRENT_PRICING.materialMultipliers[analysis.material] || 1.0;
    multiplier *= matFactor;
    if (matFactor > 1) logs.push(`Material (${analysis.material}): +${Math.round((matFactor-1)*100)}%`);

    // 2. Fator Peeling (O mais cr√≠tico para lucro/preju√≠zo)
    if (analysis.has_peeling) {
      multiplier *= CURRENT_PRICING.peelingMultiplier;
      logs.push(`Peeling Detected: +${Math.round((CURRENT_PRICING.peelingMultiplier-1)*100)}% (Stripping required)`);
    }

    // 3. Fator Dano
    if (analysis.damage_level === 'high') {
      multiplier *= 1.25;
      logs.push(`High Damage: +25%`);
    } else if (analysis.damage_level === 'moderate') {
      multiplier *= 1.1;
      logs.push(`Moderate Damage: +10%`);
    }

    // C√°lculo Final
    const finalPriceCents = Math.round(CURRENT_PRICING.basePrice * multiplier);
    const finalPriceDollars = finalPriceCents / 100;

    // Gerar Range Psicol√≥gico (Margem de negocia√ß√£o)
    const minPrice = Math.floor(finalPriceDollars / 10) * 10; // Arredonda pra baixo (ex: 453 -> 450)
    const maxPrice = Math.ceil((finalPriceDollars * 1.2) / 10) * 10; // +20% buffer

    return {
      priceCents: finalPriceCents,
      displayRange: `$${minPrice} - $${maxPrice}`,
      breakdown: logs,
      isHighRisk: analysis.damage_level === 'high' || analysis.has_peeling
    };
  }
}

```

---

### Como aplicar isso no seu Replit/VS Code:

1. **Copie o c√≥digo do Arquivo 1** e substitua todo o conte√∫do de `shared/schema.ts`. (Aten√ß√£o: isso vai alterar seu banco de dados, rode o comando de migra√ß√£o do Drizzle depois: `npm run db:push` ou equivalente no seu `package.json`).
2. **Crie o arquivo** `server/services/vision-service.ts` e cole o c√≥digo do Arquivo 2.
3. **Crie o arquivo** `server/services/pricing-service.ts` e cole o c√≥digo do Arquivo 3.

Essa estrutura prepara seu projeto para n√£o apenas "dar um pre√ßo", mas capturar leads de forma inteligente e segura.